#!/usr/bin/env python3
"""Search for safe/aggressive parameter combinations that maximize CAGR.

This script replicates the payload generated by the Algori-C backtest UI and
submits it directly to the production endpoint while imitating the browser
headers.  Parameter ranges are supplied via a JSON configuration file so the
search space can be customised without touching the code.
"""
from __future__ import annotations

import argparse
import copy
import itertools
import json
import math
import sys
import time
from pathlib import Path
from typing import Any, Dict, Iterable, Iterator, List, MutableMapping, Optional, Sequence, Tuple, Union

import requests

# Order of the knobs inside the safe/aggressive parameter arrays used by the UI.
_PARAM_ORDER: Tuple[str, ...] = (
    "divisions",
    "max_hold_days",
    "buy_threshold_pct",
    "sell_threshold_pct",
)

# Default headers that mimic the real site.
DEFAULT_HEADERS = {
    "Referer": "https://algori-c.github.io",
    "Origin": "https://algori-c.github.io",
    "User-Agent": (
        "Mozilla/5.0 (Windows NT 10.0; Win64; x64) "
        "AppleWebKit/537.36 (KHTML, like Gecko) Chrome/140.0.0.0 "
        "Safari/537.36 Edg/140.0.0.0"
    ),
    "Accept": "application/json, text/plain, */*",
    "Content-Type": "application/json",
}


def parse_args(argv: Optional[Sequence[str]] = None) -> argparse.Namespace:
    parser = argparse.ArgumentParser(
        description=(
            "Grid-search safe/aggressive parameters for the Algori-C backtest "
            "API while imitating browser headers."
        )
    )
    parser.add_argument(
        "--config",
        type=Path,
        default=Path("configs/sample_search_space.json"),
        help="Path to the JSON configuration that defines the payload and parameter ranges.",
    )
    parser.add_argument(
        "--url",
        default="https://insangai.com/new_backtest",
        help="Endpoint to call for the backtest.",
    )
    parser.add_argument(
        "--top-k",
        type=int,
        default=5,
        help="How many of the best combinations to display at the end.",
    )
    parser.add_argument(
        "--output",
        type=Path,
        help="Optional path to a JSONL file that receives every evaluated combination.",
    )
    parser.add_argument(
        "--sleep",
        type=float,
        help="Seconds to sleep between requests (overrides config's sleep_seconds).",
    )
    parser.add_argument(
        "--timeout",
        type=float,
        default=30.0,
        help="Request timeout in seconds.",
    )
    parser.add_argument(
        "--max-errors",
        type=int,
        default=20,
        help="Abort after this many consecutive request failures.",
    )
    parser.add_argument(
        "--dry-run",
        action="store_true",
        help="Show the planned combinations without issuing HTTP requests.",
    )
    parser.add_argument(
        "--include-response",
        action="store_true",
        help="Persist the full JSON response for each attempt in the output file (can be large).",
    )
    parser.add_argument(
        "--drawdown-weight",
        type=float,
        default=1.0,
        help=(
            "Penalty multiplier applied to max_drawdown_pct when ranking results. "
            "Higher values favour lower drawdowns."
        ),
    )
    return parser.parse_args(argv)


def load_config(path: Path) -> Dict[str, Any]:
    if not path.exists():
        raise FileNotFoundError(f"Config file '{path}' does not exist")
    with path.open("r", encoding="utf-8") as fh:
        return json.load(fh)


Number = Union[int, float]


def _ensure_sequence_of_numbers(values: Iterable[Any], label: str) -> List[Number]:
    result: List[Number] = []
    for item in values:
        if isinstance(item, bool) or not isinstance(item, (int, float)):
            raise TypeError(f"'{label}' entries must be numeric, got {item!r}")
        if isinstance(item, int) and not isinstance(item, bool):
            result.append(int(item))
        else:
            result.append(float(item))
    if not result:
        raise ValueError(f"'{label}' must not be empty")
    return result


def _condense_text(text: str, limit: int = 400) -> str:
    """Return a single-line preview of text limited to `limit` characters."""
    preview = " ".join(text.split())
    if len(preview) > limit:
        preview = preview[:limit].rstrip() + "…"
    return preview


def expand_param_grid(
    grid: MutableMapping[str, Iterable[Any]],
    *,
    kind: str,
    divisions: Optional[Sequence[Number]] = None,
) -> List[List[Number]]:
    """Return a list of parameter arrays in UI order."""
    sequences: List[List[Number]] = []
    for field in _PARAM_ORDER:
        if field == "divisions" and divisions is not None:
            sequences.append(_ensure_sequence_of_numbers(divisions, f"{kind}.{field}"))
            continue
        if field not in grid:
            raise KeyError(f"Missing '{field}' inside {kind}_params")
        sequences.append(_ensure_sequence_of_numbers(grid[field], f"{kind}.{field}"))
    combinations: List[List[Number]] = []
    for combination in itertools.product(*sequences):
        combinations.append(list(combination))
    return combinations


def _group_combinations_by_division(
    combos: Sequence[Sequence[Number]],
) -> Dict[Number, List[Sequence[Number]]]:
    grouped: Dict[Number, List[Sequence[Number]]] = {}
    for combo in combos:
        if not combo:
            continue
        division = combo[0]
        grouped.setdefault(division, []).append(combo)
    return grouped


def build_payload(
    base_payload: Dict[str, Any],
    safe: Sequence[Number],
    aggressive: Sequence[Number],
) -> Dict[str, Any]:
    payload = copy.deepcopy(base_payload)
    payload["safe_params"] = list(safe)
    payload["aggressive_params"] = list(aggressive)
    return payload


def extract_cagr(data: Any) -> Optional[float]:
    """Search the JSON payload for the first numeric 'cagr_pct' value."""
    if isinstance(data, dict):
        if "cagr_pct" in data:
            value = data["cagr_pct"]
            try:
                return float(value)
            except (TypeError, ValueError):
                return None
        for value in data.values():
            nested = extract_cagr(value)
            if nested is not None:
                return nested
    elif isinstance(data, list):
        for item in data:
            nested = extract_cagr(item)
            if nested is not None:
                return nested
    return None


def iter_combinations(
    safe_combos: Sequence[Sequence[Number]],
    aggressive_combos: Sequence[Sequence[Number]],
) -> Iterator[Tuple[int, Sequence[Number], Sequence[Number]]]:
    total = len(safe_combos) * len(aggressive_combos)
    index = 0
    for safe in safe_combos:
        for aggressive in aggressive_combos:
            index += 1
            yield index, safe, aggressive
    if total == 0:
        raise ValueError("Search space is empty")


def main(argv: Optional[Sequence[str]] = None) -> int:
    args = parse_args(argv)
    config = load_config(args.config)

    try:
        base_payload = config["base_payload"]
        safe_grid = config["safe_params"]
        aggressive_grid = config["aggressive_params"]
    except KeyError as exc:
        raise KeyError("Config must define 'base_payload', 'safe_params' and 'aggressive_params'") from exc

    shared_divisions_raw = config.get("shared_divisions")
    shared_divisions: Optional[List[Number]] = None
    if shared_divisions_raw is not None:
        shared_divisions = _ensure_sequence_of_numbers(shared_divisions_raw, "shared_divisions")

    safe_combos = expand_param_grid(safe_grid, kind="safe", divisions=shared_divisions)
    aggressive_combos = expand_param_grid(aggressive_grid, kind="aggressive", divisions=shared_divisions)

    if shared_divisions:
        safe_groups = _group_combinations_by_division(safe_combos)
        aggressive_groups = _group_combinations_by_division(aggressive_combos)

        missing_safe = [div for div in shared_divisions if div not in safe_groups]
        if missing_safe:
            raise ValueError(
                f"Safe parameter grid does not define combinations for divisions {missing_safe}"
            )
        missing_aggressive = [div for div in shared_divisions if div not in aggressive_groups]
        if missing_aggressive:
            raise ValueError(
                "Aggressive parameter grid does not define combinations for divisions "
                f"{missing_aggressive}"
            )

        total_combinations = sum(
            len(safe_groups[div]) * len(aggressive_groups[div]) for div in shared_divisions
        )

        def combination_iter() -> Iterator[Tuple[int, Sequence[Number], Sequence[Number]]]:
            index = 0
            for division in shared_divisions:
                for safe in safe_groups[division]:
                    for aggressive in aggressive_groups[division]:
                        index += 1
                        yield index, safe, aggressive
            if index == 0:
                raise ValueError("Search space is empty")

    else:
        total_combinations = len(safe_combos) * len(aggressive_combos)

        def combination_iter() -> Iterator[Tuple[int, Sequence[Number], Sequence[Number]]]:
            yield from iter_combinations(safe_combos, aggressive_combos)

    if total_combinations == 0:
        print("No combinations to evaluate.")
        return 1

    sleep_seconds = args.sleep if args.sleep is not None else float(config.get("sleep_seconds", 0.0))

    session = requests.Session()
    session.headers.update(DEFAULT_HEADERS)

    best: Optional[Dict[str, Any]] = None
    results: List[Dict[str, Any]] = []
    consecutive_errors = 0

    print(
        f"Evaluating {total_combinations} combinations "
        f"({len(safe_combos)} safe × {len(aggressive_combos)} aggressive)."
    )

    if args.dry_run:
        for idx, safe, aggressive in combination_iter():
            payload = build_payload(base_payload, safe, aggressive)
            print(f"[DRY-RUN] {idx:4d}/{total_combinations}: safe={safe} aggressive={aggressive}")
            print(json.dumps(payload, ensure_ascii=False))
        return 0

    for idx, safe, aggressive in combination_iter():
        payload = build_payload(base_payload, safe, aggressive)
        print(f"{idx:4d}/{total_combinations}: safe={safe} aggressive={aggressive}")
        try:
            response = session.post(args.url, json=payload, timeout=args.timeout)
        except requests.RequestException as exc:
            consecutive_errors += 1
            print(
                f"  Request error ({consecutive_errors} consecutive errors): "
                f"{exc.__class__.__name__}: {exc}"
            )
            if consecutive_errors >= args.max_errors:
                print("Too many consecutive errors; aborting search.")
                break
            if sleep_seconds:
                time.sleep(sleep_seconds)
            continue

        if response.status_code >= 400:
            consecutive_errors += 1
            reason = response.reason or "Unknown"
            print(
                f"  HTTP {response.status_code} error ({consecutive_errors} consecutive errors): {reason}"
            )
            preview = _condense_text(response.text)
            if preview:
                print(f"  Response preview: {preview}")
            if consecutive_errors >= args.max_errors:
                print("Too many consecutive errors; aborting search.")
                break
            if sleep_seconds:
                time.sleep(sleep_seconds)
            continue

        consecutive_errors = 0

        try:
            data = response.json()
        except ValueError:
            consecutive_errors += 1
            preview = _condense_text(response.text)
            print(
                f"  Failed to decode JSON response ({consecutive_errors} consecutive errors)."
            )
            if preview:
                print(f"  Response preview: {preview}")
            if consecutive_errors >= args.max_errors:
                print("Too many consecutive errors; aborting search.")
                break
            if sleep_seconds:
                time.sleep(sleep_seconds)
            continue

        cagr = extract_cagr(data)
        drawdown: Optional[float] = None
        if isinstance(data, dict) and "max_drawdown_pct" in data:
            try:
                drawdown = float(data["max_drawdown_pct"])
            except (TypeError, ValueError):
                drawdown = None
        if cagr is None:
            print("  Warning: 'cagr_pct' not found in response.")
        else:
            print(f"  CAGR: {cagr:.4f}%")
        if drawdown is not None:
            print(f"  Max drawdown: {drawdown:.4f}%")

        record = {
            "safe_params": list(safe),
            "aggressive_params": list(aggressive),
            "cagr_pct": cagr,
            "max_drawdown_pct": drawdown,
        }
        if args.include_response:
            record["response"] = data

        score: Optional[float] = None
        if cagr is not None:
            penalty = drawdown if drawdown is not None else 0.0
            score = cagr - args.drawdown_weight * penalty
            record["score"] = score
        results.append(record)

        if cagr is not None:
            if not best or (best.get("cagr_pct") is None or cagr > best["cagr_pct"]):
                best = {
                    "safe_params": list(safe),
                    "aggressive_params": list(aggressive),
                    "cagr_pct": cagr,
                    "max_drawdown_pct": drawdown,
                    "response": data,
                }

        if args.output:
            args.output.parent.mkdir(parents=True, exist_ok=True)
            with args.output.open("a", encoding="utf-8") as fh:
                json.dump(record, fh, ensure_ascii=False)
                fh.write("\n")

        if sleep_seconds:
            time.sleep(sleep_seconds)

    if best:
        print("\nBest combination found:")
        print(
            json.dumps(
                {
                    "safe_params": best["safe_params"],
                    "aggressive_params": best["aggressive_params"],
                    "cagr_pct": best["cagr_pct"],
                    "max_drawdown_pct": best.get("max_drawdown_pct"),
                },
                ensure_ascii=False,
                indent=2,
            )
        )
    else:
        print("No successful responses were recorded.")

    if args.top_k and results:
        valid_results = [r for r in results if r.get("cagr_pct") is not None]
        if valid_results:
            sorted_by_score = sorted(
                valid_results,
                key=lambda item: (
                    math.inf if item.get("score") is None else -item["score"],
                    -item["cagr_pct"],
                    item.get("max_drawdown_pct", float("inf")),
                ),
            )
            print(f"\nTop {min(args.top_k, len(sorted_by_score))} combinations (score=cagr - drawdown×{args.drawdown_weight}):")
            for rank, record in enumerate(sorted_by_score[: args.top_k], start=1):
                drawdown_text = (
                    f"{record['max_drawdown_pct']:.4f}%" if record.get("max_drawdown_pct") is not None else "n/a"
                )
                score_text = (
                    f"{record['score']:.4f}" if record.get("score") is not None else "n/a"
                )
                print(
                    f"  #{rank}: score={score_text} CAGR={record['cagr_pct']:.4f}% "
                    f"drawdown={drawdown_text} safe={record['safe_params']} aggressive={record['aggressive_params']}"
                )

    return 0


if __name__ == "__main__":
    sys.exit(main())
