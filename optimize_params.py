#!/usr/bin/env python3
"""Search for safe/aggressive parameter combinations that maximize CAGR.

This script replicates the payload generated by the Algori-C backtest UI and
submits it directly to the production endpoint while imitating the browser
headers.  Parameter ranges are supplied via a JSON configuration file so the
search space can be customised without touching the code.
"""
from __future__ import annotations

import argparse
import copy
import itertools
import json
import sys
import time
from pathlib import Path
from typing import Any, Dict, Iterable, Iterator, List, MutableMapping, Optional, Sequence, Tuple

import requests

# Order of the knobs inside the safe/aggressive parameter arrays used by the UI.
_PARAM_ORDER: Tuple[str, ...] = (
    "divisions",
    "max_hold_days",
    "buy_threshold_pct",
    "sell_threshold_pct",
)

# Default headers that mimic the real site.
DEFAULT_HEADERS = {
    "Referer": "https://algori-c.github.io",
    "Origin": "https://algori-c.github.io",
    "User-Agent": (
        "Mozilla/5.0 (Windows NT 10.0; Win64; x64) "
        "AppleWebKit/537.36 (KHTML, like Gecko) Chrome/140.0.0.0 "
        "Safari/537.36 Edg/140.0.0.0"
    ),
    "Accept": "application/json, text/plain, */*",
    "Content-Type": "application/json",
}


def parse_args(argv: Optional[Sequence[str]] = None) -> argparse.Namespace:
    parser = argparse.ArgumentParser(
        description=(
            "Grid-search safe/aggressive parameters for the Algori-C backtest "
            "API while imitating browser headers."
        )
    )
    parser.add_argument(
        "--config",
        type=Path,
        default=Path("configs/sample_search_space.json"),
        help="Path to the JSON configuration that defines the payload and parameter ranges.",
    )
    parser.add_argument(
        "--url",
        default="https://insangai.com/new_backtest",
        help="Endpoint to call for the backtest.",
    )
    parser.add_argument(
        "--top-k",
        type=int,
        default=5,
        help="How many of the best combinations to display at the end.",
    )
    parser.add_argument(
        "--output",
        type=Path,
        help="Optional path to a JSONL file that receives every evaluated combination.",
    )
    parser.add_argument(
        "--sleep",
        type=float,
        help="Seconds to sleep between requests (overrides config's sleep_seconds).",
    )
    parser.add_argument(
        "--timeout",
        type=float,
        default=30.0,
        help="Request timeout in seconds.",
    )
    parser.add_argument(
        "--max-errors",
        type=int,
        default=20,
        help="Abort after this many consecutive request failures.",
    )
    parser.add_argument(
        "--dry-run",
        action="store_true",
        help="Show the planned combinations without issuing HTTP requests.",
    )
    parser.add_argument(
        "--include-response",
        action="store_true",
        help="Persist the full JSON response for each attempt in the output file (can be large).",
    )
    return parser.parse_args(argv)


def load_config(path: Path) -> Dict[str, Any]:
    if not path.exists():
        raise FileNotFoundError(f"Config file '{path}' does not exist")
    with path.open("r", encoding="utf-8") as fh:
        return json.load(fh)


def _ensure_sequence_of_numbers(values: Iterable[Any], label: str) -> List[float]:
    result: List[float] = []
    for item in values:
        if not isinstance(item, (int, float)):
            raise TypeError(f"'{label}' entries must be numeric, got {item!r}")
        result.append(float(item))
    if not result:
        raise ValueError(f"'{label}' must not be empty")
    return result


def expand_param_grid(grid: MutableMapping[str, Iterable[Any]], *, kind: str) -> List[List[float]]:
    """Return a list of parameter arrays in UI order."""
    sequences: List[List[float]] = []
    for field in _PARAM_ORDER:
        if field not in grid:
            raise KeyError(f"Missing '{field}' inside {kind}_params")
        sequences.append(_ensure_sequence_of_numbers(grid[field], f"{kind}.{field}"))
    combinations: List[List[float]] = []
    for combination in itertools.product(*sequences):
        combinations.append([float(value) for value in combination])
    return combinations


def build_payload(base_payload: Dict[str, Any], safe: Sequence[float], aggressive: Sequence[float]) -> Dict[str, Any]:
    payload = copy.deepcopy(base_payload)
    payload["safe_params"] = list(safe)
    payload["aggressive_params"] = list(aggressive)
    return payload


def extract_cagr(data: Any) -> Optional[float]:
    """Search the JSON payload for the first numeric 'cagr_pct' value."""
    if isinstance(data, dict):
        if "cagr_pct" in data:
            value = data["cagr_pct"]
            try:
                return float(value)
            except (TypeError, ValueError):
                return None
        for value in data.values():
            nested = extract_cagr(value)
            if nested is not None:
                return nested
    elif isinstance(data, list):
        for item in data:
            nested = extract_cagr(item)
            if nested is not None:
                return nested
    return None


def iter_combinations(
    safe_combos: Sequence[Sequence[float]],
    aggressive_combos: Sequence[Sequence[float]],
) -> Iterator[Tuple[int, Sequence[float], Sequence[float]]]:
    total = len(safe_combos) * len(aggressive_combos)
    index = 0
    for safe in safe_combos:
        for aggressive in aggressive_combos:
            index += 1
            yield index, safe, aggressive
    if total == 0:
        raise ValueError("Search space is empty")


def main(argv: Optional[Sequence[str]] = None) -> int:
    args = parse_args(argv)
    config = load_config(args.config)

    try:
        base_payload = config["base_payload"]
        safe_grid = config["safe_params"]
        aggressive_grid = config["aggressive_params"]
    except KeyError as exc:
        raise KeyError("Config must define 'base_payload', 'safe_params' and 'aggressive_params'") from exc

    safe_combos = expand_param_grid(safe_grid, kind="safe")
    aggressive_combos = expand_param_grid(aggressive_grid, kind="aggressive")

    total_combinations = len(safe_combos) * len(aggressive_combos)
    if total_combinations == 0:
        print("No combinations to evaluate.")
        return 1

    sleep_seconds = args.sleep if args.sleep is not None else float(config.get("sleep_seconds", 0.0))

    session = requests.Session()
    session.headers.update(DEFAULT_HEADERS)

    best: Optional[Dict[str, Any]] = None
    results: List[Dict[str, Any]] = []
    consecutive_errors = 0

    print(
        f"Evaluating {total_combinations} combinations "
        f"({len(safe_combos)} safe Ã— {len(aggressive_combos)} aggressive)."
    )

    if args.dry_run:
        for idx, safe, aggressive in iter_combinations(safe_combos, aggressive_combos):
            payload = build_payload(base_payload, safe, aggressive)
            print(f"[DRY-RUN] {idx:4d}/{total_combinations}: safe={safe} aggressive={aggressive}")
            print(json.dumps(payload, ensure_ascii=False))
        return 0

    for idx, safe, aggressive in iter_combinations(safe_combos, aggressive_combos):
        payload = build_payload(base_payload, safe, aggressive)
        print(f"{idx:4d}/{total_combinations}: safe={safe} aggressive={aggressive}")
        try:
            response = session.post(args.url, json=payload, timeout=args.timeout)
            response.raise_for_status()
            consecutive_errors = 0
        except requests.RequestException as exc:
            consecutive_errors += 1
            print(f"  Request failed ({consecutive_errors} consecutive errors): {exc}")
            if consecutive_errors >= args.max_errors:
                print("Too many consecutive errors; aborting search.")
                break
            if sleep_seconds:
                time.sleep(sleep_seconds)
            continue

        try:
            data = response.json()
        except ValueError:
            consecutive_errors += 1
            print(f"  Failed to decode JSON response ({consecutive_errors} consecutive errors).")
            if consecutive_errors >= args.max_errors:
                print("Too many consecutive errors; aborting search.")
                break
            if sleep_seconds:
                time.sleep(sleep_seconds)
            continue

        cagr = extract_cagr(data)
        if cagr is None:
            print("  Warning: 'cagr_pct' not found in response.")
        else:
            print(f"  CAGR: {cagr:.4f}%")

        record = {
            "safe_params": list(safe),
            "aggressive_params": list(aggressive),
            "cagr_pct": cagr,
        }
        if args.include_response:
            record["response"] = data
        results.append(record)

        if cagr is not None:
            if not best or (best.get("cagr_pct") is None or cagr > best["cagr_pct"]):
                best = {
                    "safe_params": list(safe),
                    "aggressive_params": list(aggressive),
                    "cagr_pct": cagr,
                    "response": data,
                }

        if args.output:
            args.output.parent.mkdir(parents=True, exist_ok=True)
            with args.output.open("a", encoding="utf-8") as fh:
                json.dump(record, fh, ensure_ascii=False)
                fh.write("\n")

        if sleep_seconds:
            time.sleep(sleep_seconds)

    if best:
        print("\nBest combination found:")
        print(
            json.dumps(
                {
                    "safe_params": best["safe_params"],
                    "aggressive_params": best["aggressive_params"],
                    "cagr_pct": best["cagr_pct"],
                },
                ensure_ascii=False,
                indent=2,
            )
        )
    else:
        print("No successful responses were recorded.")

    if args.top_k and results:
        valid_results = [r for r in results if r.get("cagr_pct") is not None]
        valid_results.sort(key=lambda item: item["cagr_pct"], reverse=True)
        if valid_results:
            print(f"\nTop {min(args.top_k, len(valid_results))} combinations:")
            for rank, record in enumerate(valid_results[: args.top_k], start=1):
                print(
                    f"  #{rank}: CAGR={record['cagr_pct']:.4f}% "
                    f"safe={record['safe_params']} aggressive={record['aggressive_params']}"
                )

    return 0


if __name__ == "__main__":
    sys.exit(main())